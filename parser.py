#!/usr/bin/env python

import argparse
import sys
import time
import os
import re
import shutil

expected_header = "UID    PID COMM          FD PATH"

file_list = []

def save_files(save_file):
    if save_file:
        if not os.path.isdir(save_file):
            os.makedirs(save_file)
        for path in file_list:
            if os.path.isfile(path):
                path_dir = os.path.dirname(path)
                final_dir = save_file + '/' + path_dir
                if not os.path.exists(final_dir):
                    os.makedirs(final_dir)
                try:
                    shutil.copy(path, final_dir)
                except:
                    print("[-] Failed to copy " + path)

def save_log(log_file):
    if log_file:
        with open(log_file, 'w') as log:
            for path in file_list:
                if os.path.isfile(path):
                    log.write(path + '\n')

def handle_path(path):
    if os.path.isfile(path):
        if path not in file_list:
            file_list.append(path)

def process(line):
    cleaned = re.sub(' +', ' ', line)
    parts = cleaned.split(' ', 4) # we expect 5 elements, the last one can have white spaces in it

    if 5 == len(parts):
        # first item needs to be the UID which is a number
        if parts[0].isdigit():
            # first item of the path needs to be the beginning of a path
            if parts[4][0] == '/':
                handle_path(parts[4])
    else:
        print("too few elements (" + len(parts) + ") unrecognized line: " + line)


def main():
    parser = argparse.ArgumentParser(description='Parse opensnoop output to determine modified files, reads from stdin, must be run by root')
    parser.add_argument('-l','--log', nargs='?', help='Logs modified files')
    parser.add_argument('-s','--save', nargs='?', help='must be a valid directory where to copy changed files to')
    parsed = parser.parse_args()

    log_file = ''
    save_dir = ''

    if parsed.log:
        log_file = parsed.log

    if parsed.save:
        save_dir = parsed.save
    try:
        first_line_parsed = False
        while True:
            line = sys.stdin.readline().strip()
            if not first_line_parsed and line != expected_header:
                print("expecting header:" + expected_header)
                sys.exit(-1)
            if line:
                if line != expected_header:
                    process(line)
                else:
                    first_line_parsed = True
            else:
                time.sleep(0.5)
    except KeyboardInterrupt:
        save_log(log_file)
        save_files(save_dir)

if __name__ == "__main__":
    main()
